# Retro Arcade Hub - 資安審計與滲透測試報告
**Security Audit & Penetration Testing Report**

**報告日期:** 2025/12/18  
**專案名稱:** ME2025 Final Project (Retro Arcade Hub)  
**審計對象:** 網站原始碼 (Python/Flask, SQLite, Frontend JS)  
**報告等級:** 機密 (Confidential)

---

## 1. 執行摘要 (Executive Summary)

本報告針對 Retro Arcade Hub 平台進行了全面的原始碼安全審計與架構分析。整體而言，該平台在**業務邏輯安全 (Business Logic Security)** 與**防作弊機制 (Anti-Cheat)** 方面表現出色，展現了超越一般學生專案的資安意識。然而，在標準 Web 應用程式安全層面（如 CSRF 防護、密鑰管理）仍存在部分可改進之處。

**綜合安全評級: B+ (優良)**

*   **主要優勢:**
    *   具備多層次的伺服器端防作弊驗證（物理極限檢測、統計異常檢測）。
    *   密碼儲存採用業界標準的雜湊演算法 (Scrypt/PBKDF2)。
    *   敏感操作（如檔案上傳、管理員權限）具備嚴格的身分驗證。
*   **主要風險:**
    *   缺乏 CSRF (跨站請求偽造) 防護代幣。
    *   部分敏感設定（如密鑰 Salt）暴露於前端程式碼中。
    *   預設開發金鑰可能導致正式環境的安全隱憂。

---

## 2. 系統架構與威脅模型 (System Architecture & Threat Model)

### 2.1 技術堆疊
*   **後端框架:** Python Flask (Werkzeug Server)
*   **資料庫:** SQLite 3 (關聯式資料庫)
*   **前端:** HTML5, CSS3, Vanilla JS (無大型前端框架)
*   **部署環境:** 預設為 Localhost / Docker (假設)

### 2.2 關鍵資產
1.  **使用者身分資料:** 帳號、雜湊密碼、管理員權限。
2.  **虛擬經濟系統:** 分數 (Scores)、代幣 (Tickets)、已購物品 (Items)。
3.  **遊戲公平性:** 排行榜的真實性。

### 2.3 威脅模型 (Threat Modeling)
*   **外部攻擊者:** 試圖進行 SQL 注入、XSS 攻擊或暴力破解密碼。
*   **惡意玩家 (Cheaters):** 試圖透過修改記憶體、攔截封包或腳本自動化來偽造高分。
*   **權限提升:** 普通使用者試圖存取 `/admin` 路由。

---

## 3. 安全控制詳細分析 (Detailed Security Control Analysis)

### 3.1 身分驗證與授權 (Authentication & Authorization)
*   **密碼學儲存:** 系統正確使用了 `werkzeug.security.generate_password_hash` 與 `check_password_hash`。這意味著即使資料庫外洩，攻擊者也無法輕易還原原始密碼。
*   **Session 管理:** 使用 Flask 的 Signed Cookie Session (`app.secret_key`)，防止客戶端篡改 Session 內容（如偽造 `user_id` 或 `is_admin`）。
*   **存取控制:** 所有敏感路由（如 `/api/buy`, `/admin`）均檢查了 `user_id` 是否存在於 Session 中。管理員路由更進一步檢查了 `is_admin` 欄位。

### 3.2 資料庫安全 (Database Security)
*   **SQL 注入防護:** 程式碼在所有 SQL 查詢中均使用了 **參數化查詢 (Parameterized Queries)**（例如 `?` 佔位符），而非字串串接。這有效地杜絕了 SQL Injection 攻擊，這是 Web 安全中最關鍵的一環。
    *   *證據:* `database.py` 中 `conn.execute('SELECT ... WHERE username = ?', (username,))`。

### 3.3 遊戲防作弊機制 (Game Integrity & Anti-Cheat)
這是本專案最強大的安全亮點。系統採用了「**縱深防禦 (Defense in Depth)**」策略：

1.  **第一道防線 - 雜湊簽章 (Cryptographic Signature):**
    *   前端 `security.js` 與後端 `app.py` 共享一組 Salt。
    *   提交分數時，必須附帶 `Hash = SHA256(Score + Nonce + Salt)`。
    *   **效果:** 防止簡易的封包重放 (Replay Attack) 與參數篡改。

2.  **第二道防線 - 伺服器端啟發式檢測 (Server-side Heuristics):**
    *   後端 `validate_game_logic` 函式針對每款遊戲實作了物理極限檢查。
    *   **Snake:** 檢查移動步數與分數的比例（防止瞬移）。
    *   **Tetris:** 檢查方塊生成速率與消行效率（防止自動消除掛）。
    *   **Dino/Whac-A-Mole:** 基於時間與點擊數的物理極限（防止加速器）。
    *   **效果:** 即使攻擊者破解了 Hash 算法，若送出的數據不符合遊戲邏輯（例如 0.1 秒內得 1000 分），仍會被後端攔截並標記為嫌疑犯 (`is_suspect`)。

### 3.4 輸入驗證與檔案安全 (Input Validation)
*   **檔案上傳:** 使用了 `werkzeug.utils.secure_filename` 清洗檔名，並限制副檔名為圖片格式。這防止了攻擊者上傳 `.py` 或 `.php` 等惡意腳本至伺服器執行。
*   **路徑遍歷防護:** 上傳路徑被嚴格限制在 `static/uploads`，且檔名經過雜湊處理，避免路徑遍歷攻擊 (Directory Traversal)。

---

## 4. 脆弱性評估與發現 (Vulnerability Assessment)

### 4.1 高風險 (High Risk)
*   **缺乏 CSRF 防護 (Missing CSRF Protection):**
    *   *描述:* 表單（如登入、修改個人資料、刪除帳號）未使用 CSRF Token。
    *   *影響:* 攻擊者可誘使已登入的使用者點擊惡意連結，在使用者不知情的情況下修改其密碼或刪除帳號。
    *   *建議:* 引入 `Flask-WTF` 並在所有 POST 表單中加入 `<input type="hidden" name="csrf_token" ...>`。

### 4.2 中風險 (Medium Risk)
*   **前端 Salt 洩露 (Client-side Secret Exposure):**
    *   *描述:* `security.js` 中包含 `SHARED_SALT` 明文。
    *   *影響:* 具備程式碼閱讀能力的攻擊者可以提取 Salt 並自行撰寫腳本生成合法 Hash，繞過第一道防線。
    *   *緩解:* 雖然這在純前端遊戲中難以完全避免，但目前的伺服器端邏輯驗證（第二道防線）已大幅降低此風險。

*   **開發金鑰硬編碼 (Hardcoded Secret Key):**
    *   *描述:* `app.secret_key` 預設為 `'dev-secret-change-me'`。
    *   *影響:* 若在生產環境未設定 `FLASK_SECRET_KEY` 環境變數，攻擊者可偽造 Session Cookie，進而竊取任意帳號或提升為管理員。

### 4.3 低風險 (Low Risk)
*   **頻率限制實作 (Rate Limiting Implementation):**
    *   *描述:* 使用記憶體內的 Python `dict` 進行 API 限流。
    *   *影響:* 若伺服器重啟，限流記錄將消失。且在多 Worker 環境下無法共享狀態。

---

## 5. 結論與建議 (Conclusion & Recommendations)

**Retro Arcade Hub** 是一個安全性相當成熟的專案，特別是在遊戲邏輯驗證與資料庫操作上展現了專業水準。開發團隊清楚了解「**永遠不要信任客戶端 (Never Trust the Client)**」的核心資安原則，並成功實作了後端驗證邏輯。

**改進建議清單:**

1.  **[必要]** 在生產環境部署時，務必透過環境變數設定強強度的 `FLASK_SECRET_KEY`。
2.  **[建議]** 實作 CSRF Protection，特別是針對「刪除帳號」與「修改密碼」等敏感操作。
3.  **[優化]** 考慮將 Rate Limiting 邏輯遷移至 Redis 或使用 Flask-Limiter 套件，以獲得更穩定的防護。
4.  **[進階]** 雖然前端 Salt 難以隱藏，可考慮使用 WebAssembly (Wasm) 將加密邏輯編譯為二進位檔，增加逆向工程的難度。

---
*Report generated by AI Security Assistant for User.*


